#include <iostream>
#include <vector>

using namespace std;

typedef struct graph {
	int E = 0, V = 0;
	vector<vector<int>> g;
};

typedef graph* Graph;

class GrApH {
public:
	Graph GRAPHInit(int V) {
		Graph gr = new graph;
		gr->V = V; // Записываем количество вершин

		vector<vector<int>> gt(V + 1);
		int NeOr, Or;
		cout << "Количество неориентированных ребер = ";
		cin >> NeOr;
		cout << "Количество ориентированных ребер = ";
		cin >> Or;
		gr->E = Or + 2 * NeOr;

		for (int k = Or + 2 * NeOr; k > 0; k--) {
			int v1, v2, distance;
			cin >> v1 >> v2 >> distance;

			if (distance > gt[v1].size()) { // Если дистанция больше допустимой на текущем шаге
				gt[v1].resize(distance + 100); // Расширяем список, который отвечает за дистанции
			}
			auto iter = gt[v1].cbegin();
			gt[v1].insert(iter + v2, distance); // Создаем связь между вершинами и записываем
			// дистанцию между ними
		}
		gr->g = gt;
		return gr;
	}

	void printGraph(Graph Gr) {
		cout << "\n---ОТОБРАЖЕНИЕ ГРАФА В ПАМЯТИ---\n\n";
		for (int i = 1; i != Gr->g.size(); i++) { // Пока основной список вершин не пройден
			for (int y = 0; y != Gr->g[i].size(); y++) { // Пока список подчиненных вершин не пройден
				if (Gr->g[i][y] != 0) cout << "Вершина " << i << " соединена с вершиной " << y << "\n";
			}
		}
	}

	void degreeVertex(Graph Gr) {
		int toVertex, deg = 0;
		cout << "Степень какой вершины нужно определить?\n";
		cin >> toVertex;

		if (toVertex > Gr->g.size()) {
			cout << "Такой вершины нет в графе!\n";
			return;
		}
		else {
			for (int i = 1; i < Gr->g.size(); i++) { // Пока основной список вершин не пройден
				for (int y = 1; y < Gr->g[i].size(); y++) { // Пока подчиненные вершины не пройдены
					if ((i == toVertex || y == toVertex) && Gr->g[i][y] != 0) deg++;
					// Если одна из вершин является той, что мы ищем произвоидим инкремент deg
				}
			}
			cout << "Степень вершины " << toVertex << " равна " << deg << "\n";
		}
	}

	void dijkstra(Graph Gr) {
		int v1, v2;
		cout << "\nВведите вершину, от которой нужно построить путь\n";
		cin >> v1;
		cout << "\nВведите вершину, к которой нужно построить путь\n";
		cin >> v2;	

		bool visited[10000]; // Создаем список посещенных вершин
		int dist[10000], parents[100][100];
		// dist - массив с дистанциями между вершинами
		// parents - двумерный массив предшествующих вершин в пути

		if (v1 == v2) dist[v2] = 0;
		else {
			
			for (int i = 1; i < Gr->V + 1; i++) { // Запись дистанции каждого ребра
				dist[i] = Gr->g[v1][i]; // Записываем вес ребра в массив дистанций
				if (dist[i] == 0 && i != v1) { // Если дистанция 0 и это не вершина, от которой мы строим путь 
					dist[i] = INT_MAX; // Значение дистанции становится очень большим
				}
				visited[i] = false; // Помечаем вершину как непосещенную
			}
			dist[v1] = 0; // Назначение дистанции от изначальной вершине к самой себе = 0
			int k; // Создаем переменную, которая будет отвечать за минимальную дистанцию 
			for (int i = 1; i < Gr->V + 1; i++) { // Пока не посещены все вершины
				int min = INT_MAX; // Минимальный элемент - очень большой
				for (int j = 1; j < Gr->V + 1; j++) // Пока не посещены все подчиненные вершины текущей вершины
				{
					if (!visited[j] && dist[j] < min && dist[j] != 0)
					{ // Если мы ещё не посещали вершину, и дистанция между текущими вершинами меньше
						// чем текущее значение меньшей дистанции и дистанция между вершинами не 0
						min = dist[j]; // Минимальное значение - дистанция между текущими вершинами
						k = j; // Сохраняем индекс минимальной дистанции в массиве dist
					}
				}
				visited[k] = true; // Помечаем вершину как посещенную
				for (int j = 1; j != Gr->g[k].size() + 1; j++) { // Пока мы не прошли все вершины
					if (!visited[j] && Gr->g[k][j] != INT_MAX && dist[k] != INT_MAX && (dist[k] + Gr->g[k][j] < dist[j]) && Gr->g[k][j] != 0)
					{ // Если мы ещё не посещали вершину и дистанция между текущими вершинами не максимально большая
						// и новая дистанция будет меньше чем текущая дистанция между вершинами и расстояние между вершинами не 0
						dist[j] = dist[k] + Gr->g[k][j]; // Назначаем новую минимальную дистанцию
						for (int h = 0; h < 100; h++) {
							if (parents[j][h] = 1) parents[j][h] = -1; // Заполняем столбец отвечающий за предков текущей вершины -1
						}
						parents[j][k] = 1; // В столбце предков вершины у текущей вершины помечаем предка, заполняя
						// столбец с индексом предка единицей
					}
				}
			}
		}
		cout << v1 << " -> " << v2 << " Дистанция = " << dist[v2] << "\n"; // Вывод минимальной дистанции между вершинами
		int reparents[10000], j = 0, v2_new = v2;
		cout << "Путь: " << v1 << " -> "; // Выводим на экран вершину, от которой был построен путь
		for (int i = 0; i < Gr->V; i++) { // Проходимся во всем подчиненным вершинам текущей
			if (parents[v2_new][i] == 1) { // Если найден предок у вершины, которая сейчас является конечной в пути
				reparents[j] = i; // Тогда заносим её в массив родителей
				j++; // Инкремент итератора списка родителей
				v2_new = i; // Найденный родитель вешины становится новой текущей вершиной
				i = 0; // Начинаем цикл с самого начала
			}
		}
		for (int i = 10000; i >= 0; i--) { // Проходимся по массиву родителей конечной вершины
			if (reparents[i] > 0) cout << reparents[i] << " -> "; // Если ячейка массива больше нуля, то выводим вершину
		}
		cout << v2 << "\n"; // Выводим на экран конечную вершину пути
	}
};

int main() {
	setlocale(LC_ALL, "Russian");
	Graph Gr = new graph;
	int n;
	cout << "Количество вершин = ";
	cin >> n;

	GrApH GrapH;
	Gr = GrapH.GRAPHInit(n);

	while (true) {
		int t;
		cout << "\n-----МЕНЮ-----\n";
		cout << "1 - Вывод графа на экран\n";
		cout << "2 - Опеределить степень вершины\n";
		cout << "3 - Вывод кратчайшего пути от одной вершины к другой с помощью метода Дейкстры\n";
		cout << "0 - Выход из программы\n";
		cin >> t;
		if (t == 0) break;
		else if (t == 1) {
			GrapH.printGraph(Gr);
		}
		else if (t == 2) {
			GrapH.degreeVertex(Gr);
		}
		else if (t == 3) {
			GrapH.dijkstra(Gr);
		}
	}
}